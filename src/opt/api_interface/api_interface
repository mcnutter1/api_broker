#!/usr/bin/perl -w
use IO::Socket::INET;
use IO::Select();
use XML::Simple;
use JSON;
use Data::Dumper;
use XML::Parser;
use Storable;
use Digest::SHA1  qw(sha1 sha1_hex sha1_base64);
use Time::HiRes qw(time);
use POSIX;
use Getopt::Std;


my $VERSION = "1.1";
my $PORT = "5050";
my $XML_HEADER = "/<\?xml version=\"1.0\"\?>/";
my $HTTP_RESPONSE_OK_HEADER = "HTTP/1.0 200 OK\nServer: McNutter API Command Runner/$VERSION\nConnection: close\nContent-Type: text/xml\n\n";
my $HTTP_RESPONSE_403_HEADER = "HTTP/1.0 403 OK\nServer: McNutter API Command Runner/$VERSION\nConnection: close\nContent-Type: text/xml\n\n";
my $HTTP_RESPONSE_404_HEADER = "HTTP/1.0 404 OK\nServer: McNutter API Command Runner/$VERSION\nConnection: close\nContent-Type: text/xml\n\n";
my $HTTP_RESPONSE_500_HEADER = "HTTP/1.0 500 OK\nServer: McNutter API Command Runner/$VERSION\nConnection: close\nContent-Type: text/xml\n\n";


my %OPTIONS=();
getopts("c:m:z:", \%OPTIONS);

my $MODE = $OPTIONS{m};
my $PARAMS = $OPTIONS{z}; 
my $API_KEY_DB = "/opt/api_interface/api_key.db";
my $CONFIGURATION_FILE = $OPTIONS{c};;
my %CONFIG;
my %PLUGINS;
my %PLUGIN_INITIATORS;

my $CONTROLLERS_CB = {
			"/status" => "status_controller_cb",
			"/request" => "request_controller_cb"

			};

my $LOG_FILE = "/var/log/API_runner.log";


my %API_KEYS = ( );

# auto-flush on socket
$| = 1;

sub read_configuration {

	my $json_text = do {
   		open(my $json_fh, "<:encoding(UTF-8)", $CONFIGURATION_FILE) or die("Can't open \$filename\": $!\n");
   		local $/;
   		<$json_fh>
	};

	my $json = JSON->new;
	my $data = $json->decode($json_text);
	%CONFIG = %{$data->{configuration}};
}


sub activate_plugin {

	my $params = shift;

	$PLUGINS{$params->{name}}{status} = "active";
	$PLUGINS{$params->{name}}{initiator} = $params->{initiator};
	$PLUGINS{$params->{name}}{call_back} = $params->{call_back};

	$PLUGIN_INITIATORS{$params->{initiator}} = $params->{name};

	log_entry({level=>"INFO", message=>"Activated plugin [$params->{name}] which provides the following initiator [$params->{initiator}]"}); 
}

sub load_plugins {
	log_entry({message=>"Loading Plugins",level=>"INFO"});
	if (-d "/opt/api_interface/plugins") {
	 	opendir my $dir, "/opt/api_interface/plugins/";
        	my @found_plugins = readdir $dir;
        	closedir $dir;

	        foreach my $found_plugin (@found_plugins) {

        	        $qualified_lib = "/opt/api_interface/plugins/$found_plugin";

                	if (-f "/opt/api_interface/plugins/$found_plugin") {
                        	log_entry({message=>"Loading Plugin from file [$found_plugin]",level=>"INFO"});
                        	require $qualified_lib;
                	}
        	}
	}
}

sub log_entry {

	my $params = shift;
	my $message = $params->{message};
	my $level = $params->{level};

	open(my $fh, '>>', $CONFIG{log_file}) or die "Could not open file '$CONFIG{log_file}' $!";
	print $fh "\n" .localtime() . " - [$level] - " . $message;
	close $fh; 

}


sub load_api_key_db {

	if (-e $API_KEY_DB) {
		$api_key_db_ref = retrieve($API_KEY_DB);
		%API_KEYS = %{$api_key_db_ref};
		
	} else {
		print "API Key DB not found\n";
		exit(1);
	}
}

sub add_api_key_to_db {
	
	print "Generating API Key\n";
	$api_key = sha1_base64($PARAMS);
	print "API Key: $api_key\n\n";

	$API_KEYS{$api_key} = $PARAMS;
	store \%API_KEYS, $API_KEY_DB;
}

sub handle_packet {

	my %headers;
	my $socket = new IO::Socket::INET (
    	LocalHost => '0.0.0.0',
    	LocalPort => $CONFIG{port},
    	Proto => 'tcp',
    	Listen => 5,
    	Reuse => 1
	);
	die "cannot create socket $!\n" unless $socket;
	log_entry({level=>"INFO",message=>"Server started, listening on port $PORT"});
	while(1) {
		my %response;
    		# waiting for a new client connection
    		my $client_socket = $socket->accept();
 		my $start_ms_time = time();
    		my $client_address = $client_socket->peerhost();
    		my $client_port = $client_socket->peerport();
		log_entry({level=>"INFO",message=>"[$client_address] client connected, source port: $client_port"});
 
    		my $data = "";
    		$client_socket->recv($data, 10024);
	

		my ($header,$body) = split(/<\?xml version=\"1.0\"\?>/, $data);
                        $header_pos = 1;
                        foreach my $header_line (split(/[\r\n(\r\n)]/,$header)) {
                                $headers{method} = $header_line if $header_pos eq 1;
                         	
			        my ($header_key, $header_value) = split(": ", $header_line);
                                $headers{$header_key} = $header_value;
                                $header_pos++;
                        }
		my ($method, $path, $protocol) = split(/\s/,$headers{method});

		log_entry({level=>"INFO",message=>"[$client_address] client accessed $path"});

		if ($method eq "GET" || $method eq "POST") {

			log_entry({level=>"DEBUG",message=>"[$client_address] received $method request: $data"}) if ($PARAMS eq "debug");

			if ($CONTROLLERS_CB->{$path}) { 
			
				log_entry({level=>"DEBUG",message=>"[$client_address] matched controller for $path"}) if ($PARAMS eq "debug"); 

				my $controller = $CONTROLLERS_CB->{$path}->({client_address=>$client_address, method=>$method, body=>$body}) if $CONTROLLERS_CB->{$path};
			
				if ($controller->{success}) {

					$data = $HTTP_RESPONSE_OK_HEADER;

					$response{"response"} = $controller->{response};
					my $complete_ms_time = time();
                	        	my $time_elapsed = $complete_ms_time - $start_ms_time;
                        		$response{"elapsed_time"} = "$time_elapsed s";

				} else {
					 $data = $HTTP_RESPONSE_500_HEADER;
					 $response{'error'} = $controller->{error} || "Controller did not return success";					 
				}

			} else {
				$data = $HTTP_RESPONSE_404_HEADER;
				$response{'error'} = "Unknown controller";
			}

			my $complete_ms_time = time();
                        my $time_elapsed = $complete_ms_time - $start_ms_time;
                        $response{"elapsed_time"} = "$time_elapsed s";

			my $xs  = XML::Simple->new(ForceArray => 1, KeepRoot => 0, XMLDecl => 1,RootName => "response");
                        my $xml = $xs->XMLout(\%response);
                        log_entry({level=>"DEBUG",message=>"[$client_address] sent response: \n$xml"}) if ($PARAMS eq "debug");
                        $data = $data . $xml;
		}

		elsif ($method eq "FOO") {		
			log_entry({level=>"DEBUG",message=>"[$client_address] received POST request: $data"}) if ($PARAMS eq "debug");

			if ($body) {
    				my $hashref = XMLin($body);
				my $request_api_key = $hashref->{authentication}->{apikey};
				if ($API_KEYS{$request_api_key}) {

					log_entry({level=>"INFO",message=>"[$client_address] Authenticated by $API_KEYS{$request_api_key}"});
					foreach my $initiator (keys %{$hashref}) {
					
						if ($PLUGIN_INITIATORS{$initiator}) {

							$response{$initiator} = [$PLUGINS{$PLUGIN_INITIATORS{$initiator}}{call_back}->($hashref->{$initiator})];

						}
					}

			
                			$data = $HTTP_RESPONSE_OK_HEADER;
				} else {
					log_entry({level=>"CLIENT_WARNING",message=>"[$client_address] failed authentication using API KEY [$request_api_key]"});
					$response{'error'} = "Invalid API key";
					$data = $HTTP_RESPONSE_403_HEADER;			
				}
			} else {
				log_entry({level=>"CLIENT_ERROR",message=>"[$client_address] failed to send the right data"});
				$data = $HTTP_RESPONSE_500_HEADER;
			}
			my $complete_ms_time = time();
        		my $time_elapsed = $complete_ms_time - $start_ms_time;
        		$response{"elapsed_time"} = "$time_elapsed s";
			my $xs  = XML::Simple->new(ForceArray => 1, KeepRoot => 0, XMLDecl => 1,RootName => "response");
                       	my $xml = $xs->XMLout(\%response);
			log_entry({level=>"DEBUG",message=>"[$client_address] sent response: \n$xml"}) if ($PARAMS eq "debug");
			$data = $data . $xml;


		} else {
			log_entry({level=>"CLIENT_ERROR",message=>"[$client_address] used unsupported method"});
			$response{error} = "unsupported method";
			$data = $HTTP_RESPONSE_500_HEADER;
			my $complete_ms_time = time();
                        my $time_elapsed = $complete_ms_time - $start_ms_time;
                        $response{"elapsed_time"} = "$time_elapsed s";
                        my $xs  = XML::Simple->new(ForceArray => 1, KeepRoot => 0, XMLDecl => 1,RootName => "response");
                        my $xml = $xs->XMLout(\%response);
                        $data = $data . $xml;
		}
	

    	# write response data to the connected client
    	$client_socket->send($data);
 
    	# notify client that response has been sent
    	shutdown($client_socket, 1);
	%response = ();
	}
 	
	$socket->close();

}


sub status_controller_cb {
	$params = shift;
	$client_address = $params->{client_address};
	log_entry({level=>"DEBUG",message=>"[$client_address] entered status controller callback function"});
	
	my $response;

	if ($params->{method} eq "GET") {
		$response->{success} = "true";
		$response->{response}->{status} = "Service OK"; 
	
	} else {
		$response->{error} = "Bad method";
	}
	return $response;
}


sub request_controller_cb {
        $params = shift;
        $client_address = $params->{client_address};
        log_entry({level=>"DEBUG",message=>"[$client_address] entered request controller callback function"});

	my $response;
	if ($params->{body} && $params->{method} eq "POST") {
                                my $hashref = XMLin($params->{body});
                                my $request_api_key = $hashref->{authentication}->{apikey};
                                if ($API_KEYS{$request_api_key}) {

                                        log_entry({level=>"INFO",message=>"[$client_address] Authenticated by $API_KEYS{$request_api_key}"});
                                        foreach my $initiator (keys %{$hashref}) {

                                                if ($PLUGIN_INITIATORS{$initiator}) {

                                                        $response->{response}->{$initiator} = [$PLUGINS{$PLUGIN_INITIATORS{$initiator}}{call_back}->($hashref->{$initiator})];

                                                }
                                        }

					$response->{success} = "true";
                                        $data = $HTTP_RESPONSE_OK_HEADER;
                                } else {
                                        log_entry({level=>"CLIENT_WARNING",message=>"[$client_address] failed authentication using API KEY [$request_api_key]"});
                                        $response->{error} = "Invalid API key";
                                        $data = $HTTP_RESPONSE_403_HEADER;
                                }
                        } else {
                                log_entry({level=>"CLIENT_ERROR",message=>"[$client_address] failed to send the right data"});
                                $response->{error} = "Invalid data sent";
				$data = $HTTP_RESPONSE_500_HEADER;
                        }

        return $response;
}




if ($MODE eq "add_api_key") {

	load_api_key_db();
	add_api_key_to_db($PARAMS);
	
}

if ($MODE eq "print_api_keys") {

        load_api_key_db();

	print Dumper(\%API_KEYS);
}

if ($MODE eq "init_db") {

	store \%API_KEYS, $API_KEY_DB;
	
}

if ($MODE eq "dump_config") {

	read_configuration();
	print Dumper(\%CONFIG);
}

if ($MODE eq "daemon") {

	daemonize();
	read_configuration();
	print "Started McNutter API version $VERSION\n\nLogging output to $CONFIG{log_file}\n";	
	log_entry({level=>"INFO",message=>"Daemon Mode Started"});
	load_plugins();
	load_api_key_db();

	my $server = handle_packet();

	my $select = new IO::Select();
	$select->add($server);


}






sub daemonize {
   use POSIX;
   POSIX::setsid or die "setsid: $!";
   my $pid = fork ();
	if ($pid > 0) {
		open F, ">/var/run/api_interface.pid"; 
        	print F $pid; 
        	close F; 
	}
   if ($pid < 0) {
      die "fork: $!";
   } elsif ($pid) {
      exit 0;
   }
   chdir "/";
   umask 0;
   foreach (0 .. (POSIX::sysconf (&POSIX::_SC_OPEN_MAX) || 1024))
      { POSIX::close $_ }
   open (STDIN, "</dev/null");
   open (STDOUT, ">>$CONFIG{log_file_stdout}");
   open (STDERR, ">>$CONFIG{log_file_stdout}");
 }


sub daemonize2
{
    
    fork and exit;
    POSIX::setsid();
    fork and exit;
    umask 0;
    chdir '/';
    close STDIN;
    close STDOUT;
    close STDERR;
}
